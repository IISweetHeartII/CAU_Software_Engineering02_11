
# 설계 구조 선택의 배경 및 타당성

## 말의 정보 처리

### 말의 정보 처리 설계 구조

말의 정보는 PieceId를 통해 고유하게 식별되며, "{플레이어 번호}" * {말의 크기} 형식의 문자열로 표현됩니다. 이러한 구조는 다음과 같은 장점을 제공합니다:
- PieceId만으로 소유자와 말의 크기에 대한 정보를 얻을 수 있습니다.
- 그룹핑이 발생하면 PieceId를 수정하는 방식으로 처리할 수 있습니다.

### 말의 정보 처리 설계 구조의 타당성

만약 `Player` 클래스를 사용하여 말의 정보 책임을 가지게 된다면, 그룹핑을 처리하기위해 `GroupedPiece` 클래스를 추가로 만들어야 합니다.
이 경우, `Player` 클래스는 말의 정보와 그룹핑된 말의 정보를 모두 관리해야 하므로 책임이 분산되고 코드가 복잡해집니다.
또한 말 이동이 발생할 때마다 `Player` 클래스의 상태와 `GroupedPiece` 클래스의 상태를 동기화해야 하므로 유지보수가 어려워집니다.
결국 `Player` 클래스를 사용하지 않고 그 책임을 다른 곳으로 이전하는 것이 더 간단하고 명확한 구조가 됩니다.
따라서 PieceId를 사용하여 말의 정보를 처리하는 구조가 더 타당합니다.

## 말의 위치 저장

### 말의 위치 저장 설계 구조

게임에서 말의 위치는 Map<String, String> 형태로 저장됩니다. 키는 위치 식별자이고 값은 해당 위치에 있는 말의 정보입니다. 이러한 구조는 다음과 같은 장점을 제공합니다:

- O(1) 시간 복잡도로 특정 위치의 말 정보를 조회 가능
- 말의 이동을 Map의 key-value 쌍 갱신으로 간단히 처리
- 빈 위치와 말이 있는 위치를 명확히 구분
- 여러 말이 같은 위치에 있을 때 그룹화 처리 용이

위치 정보는 다음과 같은 메서드들을 통해 관리됩니다:

- getPositionPieceMap(): 전체 말의 위치 정보를 반환
- isCurrentPlayersPiecePresent(): 특정 위치에 현재 플레이어의 말이 있는지 확인
- isValidMove(): 시작 위치에서 목표 위치로의 이동이 유효한지 검증
- controlMovePiece(): 말의 실제 이동을 처리하고 위치 정보를 갱신

### 말의 위치 저장 설계 구조의 타당성

Map 구조와 비교하여 배열을 사용한 위치 저장 방식을 분석해보면 다음과 같습니다:

1. 배열 기반 저장의 장단점:

- 장점:
    - 메모리 사용이 효율적 (고정 크기 메모리 할당)
    - 인덱스로 직접 접근하여 빠른 조회 가능
    - 구현이 직관적이고 단순함
- 단점:
    - 빈 공간도 메모리를 차지함
    - 동적인 크기 조절이 어려움
    - 여러 말이 같은 위치에 있을 때 처리가 복잡함
    - 말의 이동 시 배열 조작이 더 복잡할 수 있음

2. Map 구조 선택 이유:

- 동적인 게임 상태 관리에 더 적합
- 그룹화된 말들의 처리가 용이
- 빈 공간에 대한 메모리 낭비가 없음
- 위치 식별자를 통한 직관적인 접근 가능

이러한 분석을 통해 Map 구조가 윷놀이 게임의 특성과 요구사항에 더 적합하다고 판단했습니다.

## 말의 이동 처리

### MVC 관점에서의 말의 이동 처리 설계 구조

말의 이동 처리는 **입력 -> 유효성 확인 -> 처리 -> 결과 반영**의 구조로 설계되었습니다. 이 구조는 입력된 명령어를 처리하기 전에 유효성을 확인하고, 유효한 경우에만 결과를 반영하는 방식입니다. 이를 통해 잘못된 입력으로 인한 오류를 최소화하고, 게임의 일관성을 유지할 수 있습니다.

- view: 사용자로부터 입력을 받는 부분입니다. 사용자가 이동할 말을 선택하고, 이동할 위치를 지정합니다.
- controller: 입력된 명령어를 처리하는 부분입니다. 사용자가 선택한 말이 이동 가능한지 확인하고, 이동할 위치가 유효한지 검증합니다.
- model: 게임의 상태를 관리하는 부분입니다. 말의 위치와 이동 가능한 위치를 저장하고, 이동 후의 상태를 업데이트합니다.
- result(view): 처리 결과를 사용자에게 보여주는 부분입니다. 이동이 성공했는지, 실패했는지에 대한 메시지를 출력합니다.

### MVC 관점에서의 말의 이동 처리 설계 구조의 타당성

각 컴포넌트의 책임이 명확하게 분리되어 있어 코드의 유지보수성과 재사용성이 향상됩니다:

1. View의 책임

- 사용자 입력을 받고 게임 상태를 표시하는 것에만 집중
- 게임 로직이나 상태 관리에 관여하지 않음
- 다른 UI로 교체하기 쉬운 구조

2. Controller의 책임

- 사용자 입력의 유효성 검증
- Model과 View 사이의 상호작용 조정
- 게임의 흐름 제어

3. Model의 책임

- 게임의 상태와 규칙을 관리
- 비즈니스 로직 처리
- 데이터의 무결성 보장

이러한 책임 분리를 통해:

- 각 컴포넌트를 독립적으로 테스트 가능
- 코드의 결합도를 낮추고 응집도를 높임
- 확장성과 유지보수성 향상

## 게임 상태 관리

### 게임 상태 설계 구조의 특징
1. **상태 플래그(state flag) 기반의 단계 관리**
    - 한 플레이어의 턴은 크게 “윷 던지기 → 말 선택 → 이동 위치 선택”의 순차적 단계로 구분되며, 각각의 상태를 boolean 플래그(`yutState`, `selectPieceState`, `selectPositionState`)로 명확히 표현합니다.
    - 각 단계에서 허용되는 입력만을 처리해 잘못된 조작이나 예외 상황을 원천적으로 차단합니다.

2. **컨트롤러 중심의 흐름 제어**
    - `GameController`에서는 사용자의 이벤트(버튼 클릭, 말 선택 등) 입력을 감지하고, 현재 상태 플래그에 따라 구체적인 행동(윷 던지기, 말 위치 선택 등)만 허용됩니다.
    - 이동이나 윷 던지기 등 주요 행동이 끝날 때마다, 다음 허용 단계로 상태 플래그를 갱신하여 일관된 게임 흐름을 유지합니다.

3. **명확한 UI-로직 분리**
    - 상태 변화에 따라 뷰(View)는 최신 게임 상태(말 위치, 점수, 턴 정보 등)를 업데이트하며, 사용자는 자연스럽게 현재 가능한 행동만을 안내받게 됩니다.
    - 이러한 구조는 입력 오류 시 사용자 피드백, 예외 상황 안내 등 사용자 경험을 향상할 수 있도록 돕습니다.

4. **추가 이동 및 턴 기능의 용이한 구현**
    - 윷/모/잡기 등으로 인한 추가 턴이나 추가 이동과 같은 복잡한 룰도 상태 플래그를 통해 신속하게 적용 및 해제할 수 있습니다.
    - 게임 종료 시에도 플래그 일괄 해제로 깔끔한 상태 전환을 구현할 수 있습니다.

### 설계 구조의 타당성

- **직관성**: 수동적인 상태 플래그 관리를 통해 각 단계의 허용 입력과 책임이 명확하게 분리되어, 개발자와 사용자 모두 게임 전개를 직관적으로 이해할 수 있습니다.
- **에러 방지**: 각 단계별로 입력값을 엄격히 제한함으로써, 잘못된 입력이나 비정상 상태로의 전이가 원천적으로 방지됩니다.
- **유지보수성/확장성**: 상태 플래그가 집중적으로 관리되기 때문에 새로운 게임 룰 추가, 상태 전이 조건의 변경 등이 간단하게 이루어집니다.
- **테스트 용이성**: 단계별 상태 변화가 명확해 단위 테스트 및 디버깅이 수월합니다.

## 게임 설정 읽기

### 게임 설정 읽기 설계 구조

게임 설정은 `config.txt` 파일로 설정할 수 있으며, 설정할 수 있는 항목은 다음과 같습니다:

- board size [4-6] 4: rectangle, 5: pentagon, 6: hexagon
- number of players [2-4]
- number of pieces [1-5]
- ui type [1-2] 1: swing, 2: javaFX
- game mode [1-2] 1: normal, 2: test

이 설정 파일은 게임 시작 시 `Config` 클래스로 읽어들여 게임의 초기 설정을 구성합니다. 다른 클래스는 `Config` 클래스를 통해 설정 정보를 가져와 사용합니다. 이 구조는 다음과 같은 장점을 제공합니다:
- 게임 설정을 외부 파일로 관리하여 코드와 분리함으로써 유지보수성을 높임
- 설정 파일을 통해 게임의 다양한 설정을 쉽게 변경 가능

### 게임 설정 읽기 설계 구조의 타당성

만약 `Config` 클래스를 사용하지 않고 각 클래스에서 직접 설정 파일을 읽어온다면, 다음과 같은 문제가 발생할 수 있습니다:
- **중복 코드**: 각 클래스에서 설정 파일을 읽는 로직이 중복되어 코드가 비대해지고 유지보수가 어려워짐

